// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AdminUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdminUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.IsStaff.Set {
			e.FieldStart("is_staff")
			s.IsStaff.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdminUser = [5]string{
	0: "id",
	1: "url",
	2: "username",
	3: "email",
	4: "is_staff",
}

// Decode decodes AdminUser from json.
func (s *AdminUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "is_staff":
			if err := func() error {
				s.IsStaff.Reset()
				if err := s.IsStaff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_staff\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdminUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdminUser) {
					name = jsonFieldsNameOfAdminUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersCreateBadRequest as json.
func (s *AdminUsersCreateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersCreateBadRequest from json.
func (s *AdminUsersCreateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersCreateBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersCreateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersCreateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersCreateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersCreateNotFound as json.
func (s *AdminUsersCreateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersCreateNotFound from json.
func (s *AdminUsersCreateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersCreateNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersCreateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersCreateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersCreateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersDestroyBadRequest as json.
func (s *AdminUsersDestroyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersDestroyBadRequest from json.
func (s *AdminUsersDestroyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersDestroyBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersDestroyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersDestroyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersDestroyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersDestroyForbidden as json.
func (s *AdminUsersDestroyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersDestroyForbidden from json.
func (s *AdminUsersDestroyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersDestroyForbidden to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersDestroyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersDestroyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersDestroyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersDestroyNotFound as json.
func (s *AdminUsersDestroyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersDestroyNotFound from json.
func (s *AdminUsersDestroyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersDestroyNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersDestroyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersDestroyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersDestroyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersDestroyUnauthorized as json.
func (s *AdminUsersDestroyUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersDestroyUnauthorized from json.
func (s *AdminUsersDestroyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersDestroyUnauthorized to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersDestroyUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersDestroyUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersDestroyUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersListForbidden as json.
func (s *AdminUsersListForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersListForbidden from json.
func (s *AdminUsersListForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersListForbidden to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersListForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersListForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersListForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersListOKApplicationJSON as json.
func (s AdminUsersListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []AdminUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AdminUsersListOKApplicationJSON from json.
func (s *AdminUsersListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersListOKApplicationJSON to nil")
	}
	var unwrapped []AdminUser
	if err := func() error {
		unwrapped = make([]AdminUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AdminUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersListOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AdminUsersListOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersListOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersListUnauthorized as json.
func (s *AdminUsersListUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersListUnauthorized from json.
func (s *AdminUsersListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersListUnauthorized to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersListUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersListUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersListUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersRetrieveForbidden as json.
func (s *AdminUsersRetrieveForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersRetrieveForbidden from json.
func (s *AdminUsersRetrieveForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersRetrieveForbidden to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersRetrieveForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersRetrieveForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersRetrieveForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersRetrieveNotFound as json.
func (s *AdminUsersRetrieveNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersRetrieveNotFound from json.
func (s *AdminUsersRetrieveNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersRetrieveNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersRetrieveNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersRetrieveNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersRetrieveNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersRetrieveUnauthorized as json.
func (s *AdminUsersRetrieveUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersRetrieveUnauthorized from json.
func (s *AdminUsersRetrieveUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersRetrieveUnauthorized to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersRetrieveUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersRetrieveUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersRetrieveUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersUpdateBadRequest as json.
func (s *AdminUsersUpdateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersUpdateBadRequest from json.
func (s *AdminUsersUpdateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersUpdateBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersUpdateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersUpdateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersUpdateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminUsersUpdateNotFound as json.
func (s *AdminUsersUpdateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes AdminUsersUpdateNotFound from json.
func (s *AdminUsersUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminUsersUpdateNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdminUsersUpdateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminUsersUpdateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminUsersUpdateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrentUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrentUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfCurrentUser = [3]string{
	0: "id",
	1: "username",
	2: "email",
}

// Decode decodes CurrentUser from json.
func (s *CurrentUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrentUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrentUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrentUser) {
					name = jsonFieldsNameOfCurrentUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrentUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrentUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmailString as json.
func (s EmailString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes EmailString from json.
func (s *EmailString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmailString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EmailString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EmailString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmailString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesCreateBadRequest as json.
func (s *FacilitiesCreateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesCreateBadRequest from json.
func (s *FacilitiesCreateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesCreateBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesCreateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesCreateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesCreateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesCreateForbidden as json.
func (s *FacilitiesCreateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesCreateForbidden from json.
func (s *FacilitiesCreateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesCreateForbidden to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesCreateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesCreateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesCreateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesDestroyBadRequest as json.
func (s *FacilitiesDestroyBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesDestroyBadRequest from json.
func (s *FacilitiesDestroyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesDestroyBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesDestroyBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesDestroyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesDestroyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesDestroyNotFound as json.
func (s *FacilitiesDestroyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesDestroyNotFound from json.
func (s *FacilitiesDestroyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesDestroyNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesDestroyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesDestroyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesDestroyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesPartialUpdateBadRequest as json.
func (s *FacilitiesPartialUpdateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesPartialUpdateBadRequest from json.
func (s *FacilitiesPartialUpdateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesPartialUpdateBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesPartialUpdateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesPartialUpdateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesPartialUpdateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesPartialUpdateNotFound as json.
func (s *FacilitiesPartialUpdateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesPartialUpdateNotFound from json.
func (s *FacilitiesPartialUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesPartialUpdateNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesPartialUpdateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesPartialUpdateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesPartialUpdateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesUpdateBadRequest as json.
func (s *FacilitiesUpdateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesUpdateBadRequest from json.
func (s *FacilitiesUpdateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesUpdateBadRequest to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesUpdateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesUpdateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesUpdateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FacilitiesUpdateNotFound as json.
func (s *FacilitiesUpdateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ProblemDetails)(s)

	unwrapped.Encode(e)
}

// Decode decodes FacilitiesUpdateNotFound from json.
func (s *FacilitiesUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacilitiesUpdateNotFound to nil")
	}
	var unwrapped ProblemDetails
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FacilitiesUpdateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacilitiesUpdateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacilitiesUpdateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EmailString as json.
func (o OptEmailString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EmailString from json.
func (o *OptEmailString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmailString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmailString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmailString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateDescription as json.
func (o OptPublicFacilityMergePatchUpdateDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicFacilityMergePatchUpdateDescription from json.
func (o *OptPublicFacilityMergePatchUpdateDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicFacilityMergePatchUpdateDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicFacilityMergePatchUpdateDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicFacilityMergePatchUpdateDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateIsActive as json.
func (o OptPublicFacilityMergePatchUpdateIsActive) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicFacilityMergePatchUpdateIsActive from json.
func (o *OptPublicFacilityMergePatchUpdateIsActive) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicFacilityMergePatchUpdateIsActive to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicFacilityMergePatchUpdateIsActive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicFacilityMergePatchUpdateIsActive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateLocation as json.
func (o OptPublicFacilityMergePatchUpdateLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicFacilityMergePatchUpdateLocation from json.
func (o *OptPublicFacilityMergePatchUpdateLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicFacilityMergePatchUpdateLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicFacilityMergePatchUpdateLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicFacilityMergePatchUpdateLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdatePriority as json.
func (o OptPublicFacilityMergePatchUpdatePriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicFacilityMergePatchUpdatePriority from json.
func (o *OptPublicFacilityMergePatchUpdatePriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicFacilityMergePatchUpdatePriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicFacilityMergePatchUpdatePriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicFacilityMergePatchUpdatePriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProblemDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProblemDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfProblemDetails = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes ProblemDetails from json.
func (s *ProblemDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProblemDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProblemDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProblemDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProblemDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicFacility) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicFacility) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPublicFacility = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "location",
	4: "priority",
	5: "is_active",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes PublicFacility from json.
func (s *PublicFacility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacility to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicFacility")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicFacility) {
					name = jsonFieldsNameOfPublicFacility[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicFacility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicFacilityMergePatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicFacilityMergePatchUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.IsActive.Set {
			e.FieldStart("is_active")
			s.IsActive.Encode(e)
		}
	}
}

var jsonFieldsNameOfPublicFacilityMergePatchUpdate = [5]string{
	0: "name",
	1: "description",
	2: "location",
	3: "priority",
	4: "is_active",
}

// Decode decodes PublicFacilityMergePatchUpdate from json.
func (s *PublicFacilityMergePatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacilityMergePatchUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "is_active":
			if err := func() error {
				s.IsActive.Reset()
				if err := s.IsActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicFacilityMergePatchUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicFacilityMergePatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacilityMergePatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateDescription as json.
func (s PublicFacilityMergePatchUpdateDescription) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringPublicFacilityMergePatchUpdateDescription:
		e.Str(s.String)
	case NullPublicFacilityMergePatchUpdateDescription:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes PublicFacilityMergePatchUpdateDescription from json.
func (s *PublicFacilityMergePatchUpdateDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacilityMergePatchUpdateDescription to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullPublicFacilityMergePatchUpdateDescription
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringPublicFacilityMergePatchUpdateDescription
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicFacilityMergePatchUpdateDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacilityMergePatchUpdateDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateIsActive as json.
func (s PublicFacilityMergePatchUpdateIsActive) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolPublicFacilityMergePatchUpdateIsActive:
		e.Bool(s.Bool)
	case NullPublicFacilityMergePatchUpdateIsActive:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes PublicFacilityMergePatchUpdateIsActive from json.
func (s *PublicFacilityMergePatchUpdateIsActive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacilityMergePatchUpdateIsActive to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolPublicFacilityMergePatchUpdateIsActive
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullPublicFacilityMergePatchUpdateIsActive
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicFacilityMergePatchUpdateIsActive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacilityMergePatchUpdateIsActive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdateLocation as json.
func (s PublicFacilityMergePatchUpdateLocation) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringPublicFacilityMergePatchUpdateLocation:
		e.Str(s.String)
	case NullPublicFacilityMergePatchUpdateLocation:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes PublicFacilityMergePatchUpdateLocation from json.
func (s *PublicFacilityMergePatchUpdateLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacilityMergePatchUpdateLocation to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullPublicFacilityMergePatchUpdateLocation
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringPublicFacilityMergePatchUpdateLocation
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicFacilityMergePatchUpdateLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacilityMergePatchUpdateLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicFacilityMergePatchUpdatePriority as json.
func (s PublicFacilityMergePatchUpdatePriority) Encode(e *jx.Encoder) {
	switch s.Type {
	case Int64PublicFacilityMergePatchUpdatePriority:
		e.Int64(s.Int64)
	case NullPublicFacilityMergePatchUpdatePriority:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes PublicFacilityMergePatchUpdatePriority from json.
func (s *PublicFacilityMergePatchUpdatePriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicFacilityMergePatchUpdatePriority to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullPublicFacilityMergePatchUpdatePriority
	case jx.Number:
		v, err := d.Int64()
		s.Int64 = int64(v)
		if err != nil {
			return err
		}
		s.Type = Int64PublicFacilityMergePatchUpdatePriority
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicFacilityMergePatchUpdatePriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicFacilityMergePatchUpdatePriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnexpectedError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnexpectedError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfUnexpectedError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes UnexpectedError from json.
func (s *UnexpectedError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnexpectedError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnexpectedError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnexpectedError) {
					name = jsonFieldsNameOfUnexpectedError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnexpectedError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnexpectedError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnexpectedErrorCode as json.
func (s UnexpectedErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnexpectedErrorCode from json.
func (s *UnexpectedErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnexpectedErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnexpectedErrorCode(v) {
	case UnexpectedErrorCodeINTERNALSERVERERROR:
		*s = UnexpectedErrorCodeINTERNALSERVERERROR
	default:
		*s = UnexpectedErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnexpectedErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnexpectedErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
